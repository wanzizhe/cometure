<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        // let obj={
        //     name:'lisi'
        // };
        // console.log(obj.name);//lisi


    //钩子函数
    
    //对象的属性   get  set 设置和获取对象参数
    // var pro =new Proxy({
    //     name:'lisi',
    //     age:18
    // },{
    //     //get是获取值之前做的事情
    //     get:(target,key,property)=>{//get获取属性
    //         console.log('get');//get获取属性
    //         // console.log(target);//{name: "lisi", age: 18}
    //         // console.log(key);//name  你要取到的对象，pro.name
    //         // console.log(property);//取到的就是Pro   Proxy {name: "lisi", age: 18}
    //         return target[key];//lisi  在得到值之前调用get函数，这就是钩子函数
    //     },
    //     //set 是改变值的时候做事，一定要有return 否则值不会被改变
    //     set:(target,key,value,receiver)=>{
    //         console.log('set');
    //         // console.log(target);//{name: "lisi", age: 18}
    //         // console.log(key);//name
    //         // console.log(value);//zhangsan 新传入的值
    //         // console.log(receiver);//Proxy {name: "lisi", age: 18}
    //         return target[key]=value;
    //     }
    // });
    // pro.name='zhangsan';
    // console.log(pro.name);//zhangsan



    //对象的方法    apply用于方法调用
    let target=()=>{
        // return 'target fn';
        console.log('target fn');
    }
    let handler={
        apply(target,ctx,args){
            console.log('apply');
            return Reflect.apply(...arguments);//固定写法
        }
    };
    let pro=new Proxy(target,handler)
    pro();//apply  target fn
    </script>
</body>
</html>